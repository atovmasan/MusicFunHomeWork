//№1

//Ответь на вопросы:

//Что такое побочный эффект в React?
//Почему побочные эффекты нельзя вызывать прямо в теле компонента?
//Когда именно запускается функция из useEffect?




/*
1)Побочный эффект (side effect) — это любое действие в компоненте, которое выходит за рамки возврата JSX и взаимодействия с локальным состоянием/пропсами.
Проще говоря, это любое взаимодействие с "внешним миром". К наиболее частым примерам относятся:
Работа с API: Запросы к серверу (fetch, axios).
Работа с DOM вручную: Изменение title страницы, подписка на события браузера (scroll, resize), прямое манипулирование элементами через document.getElementById.
Таймеры: Установка setTimeout или setInterval.
Подписки: Подключение к внешним стримам данных или WebSocket'ам.


2)Потому что тело компонента (его рендер-фаза) должно быть "чистым".
Представьте, что происходит при каждом рендере компонента:
React вычисляет, какие пропсы и состояние изменились.
React вызывает функцию вашего компонента, чтобы получить JSX.
React сравнивает новый JSX с предыдущим (реконсиляция).
React вносит необходимые изменения в DOM.
Если вы поместите побочный эффект прямо в тело компонента, он будет выполняться при каждом рендере без каких-либо ограничений. Это приведет к:
Бесконечным циклам: Эффект изменяет состояние -> это вызывает рендер -> эффект снова выполняется -> состояние снова меняется -> и так далее.
Производительности: Представьте, что при каждом рендере вы делаете новый запрос на сервер. Это убьет производительность приложения.
Несогласованности: Эффект может выполняться в момент, когда DOM еще не готов или обновляется, что приведет к ошибкам.

// ❌ ПЛОХО: вызов побочного эффекта в теле компонента
function MyComponent() {
  const [data, setData] = useState(null);

  // Этот fetch будет вызываться при КАЖДОМ рендере!
  fetch('/api/data')
    .then(response => response.json())
    .then(data => setData(data));

  return<>...</>}



3)useEffect решает проблему, описанную выше, позволяя контролировать, когда должен выполняться ваш побочный эффект. Время его выполнения зависит от переданного массива зависимостей.
После рендера: Функция-эффект всегда запускается после того, как браузер отрисовал компонент на экране. Это гарантирует, что эффект не заблокирует обновление интерфейса, даже если он содержит тяжелые вычисления.
А вот от массива зависимостей [] зависит, после какого именно рендера он сработает:
useEffect(() => { ... }) (без массива зависимостей)
Запускается: После каждого рендера компонента (и монтажа, и обновления).
useEffect(() => { ... }, []) (с пустым массивом)
Запускается: Только один раз, после первого рендера (монтажа) компонента. Идеально для начальных запросов к API.
useEffect(() => { ... }, [dependency1, dependency2]) (с массивом зависимостей)
Запускается: После первого рендера и затем только после тех рендеров, при которых хотя бы одна из зависимостей изменила свое значение.
*/















//№2

/* 
Предскажи, что произойдет в этих случаях:


1.useEffect(() => {
  console.log("effect")
})

1) Сколько раз сработает эффект?
Бесконечное количество раз (при каждом рендере компонента)
2) В какие моменты?
После первого рендера (монтажа)
После каждого последующего рендера компонента, 
независимо от того, что его вызвало (изменение состояния, пропсов или родительского компонента)




2.useEffect(() => {
  console.log("effect")
}, [])

1) Сколько раз сработает эффект?
Один раз
2) В какие моменты?
Только после первого рендера (монтажа компонента)




3.useEffect(() => {
  console.log("effect", counter)
}, [counter])
1) Сколько раз сработает эффект?
Зависит от изменений переменной counter
2) В какие моменты?
После первого рендера (монтажа)
После каждого рендера, при котором значение counter изменилось по сравнению с предыдущим рендером




Для каждого варианта опиши:
1) Сколько раз сработает эффект?
2) В какие моменты?
*/